package main

import (
	"dvnetman/pkg/file"
	"fmt"
	. "github.com/dave/jennifer/jen"
	"golang.org/x/tools/go/packages"
	"os"
	"path/filepath"
	"strings"
)

const missingTestFile = "missing_test.go"

func hasTests(pkg *packages.Package) bool {
	for _, f := range pkg.GoFiles {
		path := filepath.Dir(f)
		if files, err := os.ReadDir(path); err != nil {
			panic(err)
		} else {
			for _, entry := range files {
				if entry.Name() == missingTestFile {
					continue
				}
				if strings.HasSuffix(entry.Name(), "_test.go") {
					return true
				}
			}
		}
		return false
	}
	return false
}

func main() {
	cfg := &packages.Config{
		Mode: packages.NeedName | packages.NeedFiles,
	}
	pkgs, err := packages.Load(cfg, "./...")
	if err != nil {
		fmt.Println("Error:", err)
		return
	}
	for _, pkg := range pkgs {
		if !hasTests(pkg) && pkg.Name != "main" {
			func() {
				var u file.FileUpdate
				join := filepath.Join(filepath.Dir(pkg.GoFiles[0]), missingTestFile)
				fmt.Println("Creating", join)
				if u, err = file.NewFileUpdate(
					join, file.OnlyGenerated,
				); err != nil {
					fmt.Println("Error:", err)
					os.Exit(1)
				}
				defer u.Close()
				f := NewFile(pkg.Name)
				f.HeaderComment("Code generated by dvnetman. DO NOT EDIT.")
				f.Func().Id("TestMissing").Params(Id("t").Op("*").Qual("testing", "T")).Block()
				if err = f.Render(u); err != nil {
					fmt.Println("Error:", err)
					os.Exit(1)
				}
			}()
		}
	}
}
